<div class="md-contents"><p><strong>Redis Sentinel</strong> vs <strong>Cluster</strong>. Chúng ta sẽ cùng tìm hiểu mô hình của chúng để có lựa chọn phù hợp.</p><p><code>Redis Sentinel</code> cung cấp tính khả dụng cao cho Redis. Chúng ta có thể tạo ra một triển khai Redis Setinel tự động failover mà không cần sự can thiệp của con người.</p><p><code>Redis Cluster</code> cung cấp một triển khai trong đó dữ liệu được tự động chia cắt (sharding) trên nhiều node Redis. Ứng dụng vẫn có khả năng tiếp tục hoạt động khi một số node thất bại hoặc không thể giao tiếp.</p><div id="ez-toc-container" class="ez-toc-v2_0_50 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction"><div class="ez-toc-title-container"><p class="ez-toc-title">Mục Lục</p> <span class="ez-toc-title-toggle"><a href="#" class="ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle ez-toc-loaded" aria-label="Toggle Table of Content" role="button"><label for="item-65031e11c3059" aria-hidden="true"><span style="display: flex;align-items: center;width: 35px;height: 30px;justify-content: center;direction:ltr;"><svg style="fill: #999;color:#999" xmlns="http://www.w3.org/2000/svg" class="list-377408" width="20px" height="20px" viewBox="0 0 24 24" fill="none"><path d="M6 6H4v2h2V6zm14 0H8v2h12V6zM4 11h2v2H4v-2zm16 0H8v2h12v-2zM4 16h2v2H4v-2zm16 0H8v2h12v-2z" fill="currentColor"></path></svg><svg style="fill: #999;color:#999" class="arrow-unsorted-368013" xmlns="http://www.w3.org/2000/svg" width="10px" height="10px" viewBox="0 0 24 24" version="1.2" baseProfile="tiny"><path d="M18.2 9.3l-6.2-6.3-6.2 6.3c-.2.2-.3.4-.3.7s.1.5.3.7c.2.2.4.3.7.3h11c.3 0 .5-.1.7-.3.2-.2.3-.5.3-.7s-.1-.5-.3-.7zM5.8 14.7l6.2 6.3 6.2-6.3c.2-.2.3-.5.3-.7s-.1-.5-.3-.7c-.2-.2-.4-.3-.7-.3h-11c-.3 0-.5.1-.7.3-.2.2-.3.5-.3.7s.1.5.3.7z"></path></svg></span></label><input type="checkbox" id="item-65031e11c3059"></a></span></div><nav><ul class="ez-toc-list ez-toc-list-level-1 "><li class="ez-toc-page-1 ez-toc-heading-level-3"><a class="ez-toc-link ez-toc-heading-1" href="#Redis_Sentinel" title="Redis Sentinel">Redis Sentinel</a></li><li class="ez-toc-page-1 ez-toc-heading-level-3"><a class="ez-toc-link ez-toc-heading-2" href="#Redis_Cluster" title="Redis Cluster">Redis Cluster</a></li><li class="ez-toc-page-1 ez-toc-heading-level-3"><a class="ez-toc-link ez-toc-heading-3" href="#Redis_Sentinel_vs_Redis_Cluster" title="Redis Sentinel vs Redis Cluster">Redis Sentinel vs Redis Cluster</a></li><li class="ez-toc-page-1 ez-toc-heading-level-3"><a class="ez-toc-link ez-toc-heading-4" href="#Loi_ket" title="Lời kết">Lời kết</a></li></ul></nav></div><h3><span class="ez-toc-section" id="Redis_Sentinel" ez-toc-data-id="#Redis_Sentinel"></span>Redis Sentinel<span class="ez-toc-section-end"></span></h3><p>Nếu ứng dụng của chúng ta phụ thuộc vào một Redis server duy nhất, nếu redis server này gặp sự cố hoặc lỗi kết nối do mạng chập chờn thì trường hợp nãy ứng dụng của chúng ta sẽ bị lỗi hoặc trường hợp xấu nhất là mất dữ liệu trên redis server.</p><p>Để giải quyết vấn đề này, chúng ta có thể cấu hình thêm redis slave node để sao chép dữ liệu từ redis master node, sau đó ứng dụng sẽ đọc dữ liệu từ redis slave node cho đến khi redis master node được khôi phục. Mặc dù đây là một giải pháp nhưng có một giải pháp đáng tin cậy hơn để làm điều này đó là sử dụng Redis Sentinel.</p><p>Redis Sentinel là một hệ thống được thiết kế để giúp quản lý các Redis server. Mục đích chính của việc sử dụng Sentinel là cung cấp một hệ thống có tính khả dụng cao bằng cách giám sát, thông báo và cung cấp khả năng chuyển đổi dự phòng. Sentinel thực hiện ba nhiệm vụ sau:</p><ul><li><strong>Monitor (Giám sát)</strong>: Các Sentinel sẽ thường xuyên kiểm tra xem các redis master và redis slave có đang hoạt động như mong đợi.</li><li><strong>Notification (Thông báo)</strong>: Các Sentinel sẽ thông báo cho các Redis Sentinel khác khi giám sát thấy có điều gì đó không ổn đối với các redis server.</li><li><strong>Automatic Failover (Chuyển đổi dự phòng tự động)</strong>: Nếu redis master node có vấn đề (ví dụ down), các Sentinel sẽ thống nhất và bầu một redis slave node lên làm redis master.<br> <a href="https://viblo.asia/p/system-design-redis-high-availibility-voi-sentinel-va-replication-djeZ1E6YZWz" target="_blank" rel="noopener nofollow">Chi tiết về HA với Redis Sentinel tại đây</a>.</li></ul><p><span class="progressive-img_capturer progressive-img_wrapper article-img-wrapper"><img class="progressive-img_full progressive-img_hidden article-img lazy-load-active" width="1143" height="572" data-full-src="data:image/svg+xml,%3Csvg%20viewBox%3D%220%200%201143%20572%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3C%2Fsvg%3E" data-src="https://images.viblo.asia/bfb0100b-30fb-46be-8fea-d58905041185.png" alt="" data-tiny-src="https://images.viblo.asia/60/bfb0100b-30fb-46be-8fea-d58905041185.png" data-zoom-src="https://images.viblo.asia/full/bfb0100b-30fb-46be-8fea-d58905041185.png" data-wrapper-class="lazy-load article-img-wrapper" data-tiny-class="lazy-load article-img-tiny" data-full-class="lazy-load article-img" src="https://images.viblo.asia/bfb0100b-30fb-46be-8fea-d58905041185.png"></span></p><p>Đối với mô hình Redis Sentinel cần ít nhất 3 redis server (ví dụ 1 redis server đóng vai trò là master, 2 redis slave đóng vai trò là slave). Tương ứng với 3 redis server này sẽ có 3 sentinel giám sát. Các Redis sentinel này có thể chạy ở 3 node khác hoăc cùng node với redis server.</p><h3><span class="ez-toc-section" id="Redis_Cluster" ez-toc-data-id="#Redis_Cluster"></span>Redis Cluster<span class="ez-toc-section-end"></span></h3><p>Redis Cluster là một giải pháp phân chia dữ liệu với các tính năng quản lý tự động, chuyển đổi dự phòng và nhân bản. Shard Data là một phương pháp để chia cơ sở dữ liệu lớn (DB) thành các phần nhỏ hơn, nó <strong>rẻ hơn</strong> vì có thể dể dàng mở rộng được theo theo chiều ngang bằng cách thêm nhiều node vào cụm thay vì mở rộng theo chiều dọc bằng cách thêm cấu hình máy chủ mạnh hơn.</p><p>Nói chung, chế độ cluster cung cấp tính khả dụng cao tương tự với chế độ Sentinel nhưng <strong>Sharding cho phép lưu trữ nhiều dữ liệu hơn</strong> trong cụm. <strong>Redis cluster cải thiện hiệu suất và khả năng mở rộng của ứng dụng của chúng ta khi dữ liệu tiếp tục tăng</strong>.<br> <span class="progressive-img_capturer progressive-img_wrapper article-img-wrapper"><img class="progressive-img_full progressive-img_hidden article-img lazy-load-active" width="1152" height="559" data-full-src="data:image/svg+xml,%3Csvg%20viewBox%3D%220%200%201152%20559%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3C%2Fsvg%3E" data-src="https://images.viblo.asia/4abb2fef-44e2-44fd-9763-2da9bc873dbe.png" alt="" data-tiny-src="https://images.viblo.asia/60/4abb2fef-44e2-44fd-9763-2da9bc873dbe.png" data-zoom-src="https://images.viblo.asia/full/4abb2fef-44e2-44fd-9763-2da9bc873dbe.png" data-wrapper-class="lazy-load article-img-wrapper" data-tiny-class="lazy-load article-img-tiny" data-full-class="lazy-load article-img" src="https://images.viblo.asia/4abb2fef-44e2-44fd-9763-2da9bc873dbe.png"></span></p><h3><span class="ez-toc-section" id="Redis_Sentinel_vs_Redis_Cluster" ez-toc-data-id="#Redis_Sentinel_vs_Redis_Cluster"></span>Redis Sentinel vs Redis Cluster<span class="ez-toc-section-end"></span></h3><h4>Architecture</h4><p>Redis Cluster không có kiến trúc trung tâm. Nó tự động chia dữ liệu giữa các node khác nhau. Ngoài ra, chúng ta cần tối thiểu 3 master node và 3 slave node (6 node). Đối với Redis Sentinel, có thể xây dựng một triển khai Sentinel đầy đủ chức năng chỉ bằng 3 node.</p><h4>Availability</h4><p>Redis Sentinel cung cấp khả năng sẵn sàng rất cao mà không cần sự can thiệp của con người. Ngoài ra, với mô hình redis sentinel nếu tất cả các slave node chết nó vẫn tồn tại chỉ với một master node đang hoạt động. Mặt khác, Redis Cluster không cung cấp khả năng sẵn sàng cao được như vậy. Nếu hầu hết các master node chết thì cụm redis cluster sẽ không hoạt động.</p><h4>Scalability</h4><p>Đối với Redis cluster chúng ta có thể dễ dàng thêm hoặc xóa các node trong cụm. Redis Cluster cho phép chúng ta thêm hoặc xóa các node một cách linh hoạt. Ngoài ra, nó hỗ trợ tới một nghìn node trong hệ thống.</p><p>Ngược lại, Redis Sentinel không thể mở rộng. Các yêu cầu sẽ được điều hướng tới master node. Do đó, nó không thể giải quyết vấn đề phân tách đọc-viết.</p><h4>Data Sharding</h4><p>Trong mô hình Redis cluster, Sharding là quá trình chia dữ liệu thành các khối hoặc mảnh nhỏ hơn. Với cơ sở dữ liệu Sharding, chúng ta có khả năng chia dữ liệu cùng nằm trên một máy họăc nhiều máy. Nó chỉ là một kỹ thuật tối ưu hóa cho phép chúng ta chia dữ liệu của mình thành các phần nhỏ hơn. Do đó, chúng ta có được hiệu suất tốt hơn và lưu trữ dữ liệu nhiều hơn.</p><p>Redis Sentinel không có khả năng này.</p><h4>Replication</h4><p>Cả Redis Cluster và Redis Sentinel đều cho phép sao chép dữ liệu, nhưng cả hai đều có vấn đề của họ. Redis Cluster chỉ có thể sao chép từ master node sang slave node của nó.</p><p>Redis Sentinel cho phép sao chép dữ liệu tới nhiều slave node từ một master node.</p><p>Tuy nhiên, cả Redis Cluster và Redis Sentinel sao chép không đồng bộ dữ liệu, vì vậy ta <em><strong>cần thỏa hiệp với tính nhất quán dữ liệu</strong></em>.</p><h3><span class="ez-toc-section" id="Loi_ket" ez-toc-data-id="#Loi_ket"></span>Lời kết<span class="ez-toc-section-end"></span></h3><p>Cả hai cung cấp tính khả dụng cao cho hệ thống.</p><p>Khi <strong>tốc độ không phải là mối quan tâm chính</strong> của chúng ta, chúng ta nên sử dụng Sentinel, đây là một lựa chọn tuyệt vời cho các <strong>triển khai nhỏ</strong> (về mặt dữ liệu và lượng request truy cập) với những lo ngại về tính khả dụng cao.</p><p>Mặt khác, Redis Cluster cung cấp tính khả dụng cao cộng với một giải pháp phân cụm. Đây là một <strong>lựa chọn hoàn hảo để đảm bảo tính khả dụng cao trong khi vẫn giữ tốc độ truy cập nhanh</strong> để truy cập dữ liệu (<em>vì dữ liệu được dàn trải ở nhiều node nên lượng dữ liệu ở mỗi node sẽ nhỏ hơn tập trung ở 1 node, vì vậy mà truy cập dữ liệu sẽ nhanh hơn</em>).</p><p>Nếu chúng ta cần một giải pháp chuyển đổi dự phòng tự động mà không cần đến một giải pháp cụm hoàn chỉnh, hãy sử dụng Sentinel. Để có được một giải pháp cụm hoàn chỉnh chia cơ sở dữ liệu của chúng ta giữa nhiều node, thì chúng ta nên sử dụng Redis Cluster.</p><p>Nguồn:</p><ul><li><a href="https://cloudinfrastructureservices.co.uk/redis-sentinel-vs-cluster/#:~:text=Redis%20Sentinel%20provides%20high%20availability,sharded%20across%20multiple%20Redis%20nodes" target="_blank" rel="noopener nofollow">https://cloudinfrastructureservices.co.uk/redis-sentinel-vs-cluster/#:~:text=Redis Sentinel provides high availability,sharded across multiple Redis nodes</a>.</li></ul></div>